# -*- coding: utf-8 -*-
"""polypDetector.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13YGGdUkCsnQ_GtVBFiD82I4fxMjd8Vyl
"""

#Needed libraries
import torch
from torch import nn
import cv2
import torch
import torchvision.transforms as transforms
from PIL import Image
import numpy as np

#Device agnostic code
device = "cuda" if torch.cuda.is_available() else "cpu"

#Redefine the model architecture
class BinaryClassificationCNN(nn.Module):
    def __init__(self, input_channels: int, hidden_units: int):
        super(BinaryClassificationCNN, self).__init__()
        self.conv_block_1 = nn.Sequential(
            nn.Conv2d(in_channels=input_channels, out_channels=hidden_units, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(in_channels=hidden_units, out_channels=hidden_units, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        self.conv_block_2 = nn.Sequential(
            nn.Conv2d(in_channels=hidden_units, out_channels=hidden_units * 2, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(in_channels=hidden_units * 2, out_channels=hidden_units * 2, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        self._calculate_linear_input_size()
        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Linear(in_features=self.flattened_size, out_features=1)  # Output dimension is 1 for binary classification
        )

    def _calculate_linear_input_size(self):
        dummy_input = torch.zeros(1, 3, 128, 128)  # Example input shape: batch size 1, 3 channels, 128x128 image
        dummy_output = self.conv_block_1(dummy_input)
        dummy_output = self.conv_block_2(dummy_output)
        self.flattened_size = dummy_output.numel()  # Number of features after flattening

    def forward(self, x):
        x = self.conv_block_1(x)
        x = self.conv_block_2(x)
        x = self.classifier(x)
        return x

# Load model into python
loaded_model = BinaryClassificationCNN(input_channels=3, hidden_units=32)
loaded_model.load_state_dict(torch.load('Polyp_AI_Model_V0-2.pth', map_location=torch.device('cpu')))

# Define transformations and frame preprocessing
transform = transforms.Compose([
    transforms.Resize((128, 128)),
    transforms.ToTensor(),
])

def preprocess_frame(frame):
    # Convert the frame to PIL image
    pil_image = Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
    # Apply the transformations
    tensor_image = transform(pil_image)
    # Add a batch dimension
    tensor_image = tensor_image.unsqueeze(0)
    return tensor_image

#Evaluating on realtime data
loaded_model.eval()

def main():
  capture = cv2.VideoCapture(0)

  while True:
      ret, frame = capture.read()
      if not ret:
          break

      # Preprocess the frame
      input_tensor = preprocess_frame(frame)

      # Make a prediction
      with torch.no_grad():
          output = loaded_model(input_tensor)
          probability = torch.sigmoid(output).item()  # Apply sigmoid to get probability
          label = "Positive" if probability > 0.5 else "Negative"  # Threshold at 0.5

      cv2.putText(frame, f'Prediction: {label}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2, cv2.LINE_AA)
      cv2.imshow('Camera Feed', frame)

      # Check if the spacebar is pressed
      if cv2.waitKey(1) & 0xFF == ord(' '):
          break

  # Release the capture and close windows
  capture.release()
  cv2.destroyAllWindows()

if __name__ == "__main__":
    main()

